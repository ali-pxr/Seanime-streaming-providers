{
  "id": "animeworld",
  "name": "AnimeWorld",
  "description": "Extension for AnimeWorld, an online streaming provider for subbed/dubbes animes in Italian",
  "manifestURI": "https://raw.githubusercontent.com/kRYstall9/Seanime-streaming-providers/refs/heads/main/src/AnimeWorld/manifest.json",
  "version": "1.0.0",
  "author": "kRYstall9",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path='./online-streaming-provider.d.ts' />\n/// <reference path='./doc.d.ts' />\n\nclass Provider {\n  api: string = 'https://www.animeworld.ac';\n\n  getSettings(): Settings {\n    return {\n      episodeServers: ['AnimeWorld Server'],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query['query']);\n    console.log('Normalized Query: ' + normalizedQuery);\n\n    let url = query['dub'] ? `${this.api}/filter?dub=1&sort=0&keyword=${encodeURIComponent(normalizedQuery)}` : `${this.api}/filter?dub=0&sort=0&keyword=${encodeURIComponent(normalizedQuery)}`;\n\n    let data = await this._makeRequest(url);\n\n    if(data.includes(\"Non ci sono anime con i filtri inseriti\")){\n      url = query['dub'] ? `${this.api}/filter?dub=1&sort=0&keyword=${encodeURIComponent(this.addSeasonWordToQuery(normalizedQuery))}` : `${this.api}/filter?dub=0&sort=0&keyword=${encodeURIComponent(this.addSeasonWordToQuery(normalizedQuery))}`;\n      data = await this._makeRequest(url);\n    }\n\n    if(data.includes(\"Non ci sono anime con i filtri inseriti\")){\n      throw new Error(\"No results found\");\n    }\n\n    const $: DocSelectionFunction = LoadDoc(data);\n\n\n    let animes: SearchResult[] = $('div.film-list>div.item').map(\n      (index: number, element: DocSelection) => {\n        let aTag = element.find('.name');\n        let id: string = aTag.attr('href') ?? '';\n        let url: string = `${this.api}${id}`;\n        let title: string = aTag.text().trim();\n\n        let searchResult: SearchResult = {\n          id: id,\n          url: url,\n          title: title,\n          subOrDub: 'both'\n        }\n        return searchResult;\n      }\n    );\n    return animes;\n  }\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    const url = `${this.api}${id}`;\n\n    const data = await this._makeRequest(url);\n    const $ = LoadDoc(data);\n\n    let episodes = $('div.server.active>ul.episodes>li.episode').map((index, element) => {\n      let aTag = element.find('a');\n      let episodeId = aTag.attr('data-id') ?? \"\";\n      let url = `${this.api}/api/episode/serverPlayerAnimeWorld?id=${episodeId}`;\n      let episodeNumber = aTag.attr('data-episode-num');\n\n      let episodeDetails: EpisodeDetails = {\n        id: episodeId,\n        url: url,\n        title: `Episodio ${episodeNumber}`,\n        number: Number(episodeNumber)\n      }\n\n      return episodeDetails;\n    })\n\n\n    return episodes;\n  }\n  async findEpisodeServer(\n    episode: EpisodeDetails,\n    _server: string\n  ): Promise<EpisodeServer> {\n    let server = 'AnimeWorld Server';\n    if (_server !== 'default') server = _server;\n\n    const episodeServer: EpisodeServer = {\n      server: server,\n      headers: {\n        Referer: `${this.api}`,\n        Cookie: \"__ddg1_=;__ddg2_=;\",\n        \"Access-Control-Allow-Origin\": \"*\"\n      },\n      videoSources: [],\n    };\n\n    if (episode.url.startsWith('https')) {\n      let [videoUrl, type] = await this.getMp4Url(episode.url);\n\n      episodeServer.videoSources = [\n        {\n          quality: '720p',\n          subtitles: [],\n          type: type as VideoSourceType,\n          url: videoUrl\n        }\n      ]\n\n      return episodeServer;\n    }\n\n\n    throw new Error(\"No server found\");\n\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'text/html; charset=utf-8',\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.0.0',\n        Cookie: \"__ddg1_=;__ddg2_=;\"\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    const body = await response.text();\n    return body;\n  }\n\n  normalizeQuery(query: string): string {\n\n    const extras = [\n      'EXTRA PART',\n      'OVA',\n      'SPECIAL',\n      'RECAP',\n      'FINAL SEASON',\n      'BONUS',\n      'SIDE STORY',\n      'PART\\\\s*\\\\d+',\n      'EPISODE\\\\s*\\\\d+'\n    ];\n\n    const pattern = new RegExp(`\\\\b(${extras.join('|')})\\\\b`, 'gi');\n\n    let normalizedQuery = query\n      .replace(/\\b(\\d+)(st|nd|rd|th)\\b/g, '$1') //Removes suffixes from a number I.e. 3rd, 1st, 11th, 12th, 2nd -> 3, 1, 11, 12, 2\n      .replace(/(\\d+)\\s*Season/i, '$1') //Removes season and keeps the number before the Season word\n      .replace(/Season\\s*(\\d+)/i, '$1') //Removes season and keeps the number after the Season word\n      .replace(pattern, '') //Removes extras\n      .replace(/-.*?-/g, '') // Removes -...-\n      .replace(/\\bThe(?=\\s+Movie\\b)/gi, '')\n      .replace(/~/g, ' ') //Removes ~\n      .replace(/\\s+/g, ' ') //Replaces 1+ whitespaces with 1\n      .trim();\n\n    return normalizedQuery;\n  }\n\n\n  addSeasonWordToQuery(query: string): string {\n    if (/Season/i.test(query)) return query;\n\n    // Trova il primo numero standalone (anche con suffissi: 2nd, 3rd, etc.)\n    const match = query.match(/\\b(\\d+)(st|nd|rd|th)?\\b/);\n    if (!match || match.index === undefined) return query; // Nessun numero trovato\n\n    console.log(match);\n\n    return \"\";\n\n    // const number = match[0];\n    // const index = match.index;\n\n    // Inserisce \"Season\" PRIMA del numero\n    //return query.slice(0, index) + \"Season \" + number + query.slice(index + number.length);\n  }\n\n  async getMp4Url(url: string): Promise<string[]> {\n\n    const body = await this._makeRequest(url);\n    const $ = LoadDoc(body);\n\n    let videoTag = $('video>source');\n\n    let videoUrl = videoTag.attr('src') ?? \"\";\n    let type = videoTag.attr('type')?.split('/')[1] ?? \"\";\n\n    return [videoUrl, type];\n\n  }\n}\n"
}