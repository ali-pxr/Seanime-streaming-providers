{
  "id": "anime3rb",
  "name": "Anime3rb",
  "description": "Anime3rb is an online streaming provider for subbed/dubbed animes in Arabic",
  "manifestURI": "https://raw.githubusercontent.com/ali-pxr/Seanime-streaming-providers/refs/heads/main/src/AnimeKai/manifest.json",
  "version": "1.0.0",
  "author": "yourusername",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "ar",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\"/>\n\nclass Provider {\n  api = \"https://anime3rb.com\";\n\n  getSettings(): Settings {\n    return {\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query[\"query\"]);\n    console.log(\"Normalized Query: \" + normalizedQuery);\n\n    const url = `${this.api}/search?keyword=${encodeURIComponent(\n      normalizedQuery\n    )}`;\n\n    try {\n      const data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const animes: SearchResult[] = [];\n      $(\"div.anime-item\").each((_, elem) => {\n        const id = elem.find(\"a.poster\").attr(\"href\")?.slice(1) ?? \"\";\n        const title = elem.find(\"a.title\").attr(\"title\") ?? \"\";\n        const subOrDub: SubOrDub = this.isSubOrDubOrBoth(elem);\n        const url = `${this.api}/${id.slice(1)}`;\n\n        const anime: SearchResult = {\n          id: `${id}?dub=${query['dub']}`,\n          url: url,\n          title: title,\n          subOrDub: subOrDub,\n        };\n\n        animes.push(anime);\n      });\n\n      return animes;\n    }\n    catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    const url = `${this.api}/${id.split('?dub')[0]}`;\n    try {\n      let data: any = await this._makeRequest(url);\n      const episodes: EpisodeDetails[] = [];\n      const $ = LoadDoc(data);\n      $('ul.episode-list>li>a').each((_, elem) => {\n        const title = elem.find('span').text().trim();\n        const number = parseInt(elem.attr('data-episode-number')!, 10);\n        const episodeUrl = `${this.api}/episode/${number}`;\n\n        episodes.push({\n          id: number.toString(),\n          number: number,\n          title: title,\n          url: episodeUrl\n        });\n      });\n\n      return episodes;\n    }\n    catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodeServer(\n    episode: EpisodeDetails,\n    _server: string\n  ): Promise<EpisodeServer> {\n    const episodeUrl = episode.url;\n    try {\n      const responseText = await this._makeRequest(episodeUrl);\n      const cleanedHtml = cleanJsonHtml(responseText);\n      const streamUrlRegex = /<source src=\"([^\"]+)\"/;\n      const streamMatch = streamUrlRegex.exec(cleanedHtml);\n      const streamUrl = streamMatch ? streamMatch[1] : \"\";\n\n      if (streamUrl == \"\") {\n        throw new Error(\"Unable to find a valid source\")\n      }\n\n      const episodeServer: EpisodeServer = {\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36'\n        },\n        videoSources: [{\n          quality: '720p',\n          type: 'mp4',\n          url: streamUrl\n        }]\n      };\n\n      return episodeServer;\n    }\n    catch (e: any) {\n      throw new Error(e);\n    }\n  }\n\n  normalizeQuery(query: string): string {\n    return query.trim();\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        \"DNT\": \"1\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\",\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    const body = await response.text();\n    return body;\n  }\n\n  isSubOrDubOrBoth(elem: DocSelection): SubOrDub {\n    const sub = elem.find(\"span.sub\").text();\n    const dub = elem.find(\"span.dub\").text();\n\n    if (sub != \"\" && dub != \"\") {\n      return \"both\";\n    }\n    if (sub != \"\") {\n      return \"sub\";\n    }\n\n    return \"dub\";\n  }\n}\n\n// دالة لتحميل البيانات من anime3rb.js\nasync function loadAnime3rbScript() {\n  const response = await fetch('https://raw.githubusercontent.com/50n50/sources/main/anime3rb/anime3rb.js');\n  const script = await response.text();\n  eval(script);\n}\n\n// دالة لتحميل البيانات من anime3rb.json\nasync function loadAnime3rbJson() {\n  const response = await fetch('https://raw.githubusercontent.com/50n50/sources/main/anime3rb/anime3rb.json');\n  const jsonData = await response.json();\n  return jsonData;\n}\n"
}
