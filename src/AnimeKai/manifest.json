{
  "id": "anime3rb",
  "name": "Anime3rb",
  "description": "موفر بث مباشر لموقع Anime3rb",
  "manifestURI": "https://raw.githubusercontent.com/ali-pxr/Seanime-streaming-providers/refs/heads/main/src/AnimeKai/manifest.json",
  "version": "1.0.0",
  "author": "اسمك",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "ar",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  api = \"https://anime3rb.com\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Server 1\"],\n      supportsDub: false\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    const normalizedQuery = this.normalizeQuery(query[\"query\"]);\n    const searchUrl = `${this.api}/?s=${encodeURIComponent(normalizedQuery)}`;\n\n    try {\n      const data = await this._makeRequest(searchUrl);\n      const $ = LoadDoc(data);\n      const results: SearchResult[] = [];\n\n      $(\".anime-card\").each((_, elem) => {\n        const title = elem.find(\".anime-title\").text();\n        const url = elem.find(\"a\").attr(\"href\");\n        const id = url?.split(\"/\").pop() ?? \"\";\n\n        results.push({\n          id: id,\n          url: url,\n          title: title,\n          subOrDub: \"sub\"\n        });\n      });\n\n      return results;\n    } catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    const url = `${this.api}/anime/${id}`;\n\n    try {\n      const data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const episodes: EpisodeDetails[] = [];\n\n      $(\".episode-list a\").each((_, elem) => {\n        const episodeTitle = elem.text();\n        const episodeUrl = elem.attr(\"href\");\n        const episodeId = episodeUrl?.split(\"/\").pop() ?? \"\";\n\n        episodes.push({\n          id: episodeId,\n          number: parseInt(episodeTitle.match(/\\d+/)?.[0] || \"0\", 10),\n          title: episodeTitle,\n          url: episodeUrl\n        });\n      });\n\n      return episodes;\n    } catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    try {\n      const data = await this._makeRequest(episode.url);\n      const $ = LoadDoc(data);\n      const videoSources: VideoSource[] = [];\n\n      $(\".player iframe\").each((_, elem) => {\n        const src = elem.attr(\"src\");\n        if (src) {\n          videoSources.push({\n            quality: \"720p\",\n            subtitles: [],\n            type: \"embed\",\n            url: src\n          });\n        }\n      });\n\n      return {\n        server: _server,\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0\"\n        },\n        videoSources: videoSources\n      };\n    } catch (e: any) {\n      throw new Error(e);\n    }\n  }\n\n  normalizeQuery(query: string): string {\n    return query.replace(/\\s+/g, \" \").trim();\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0\"\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    return await response.text();\n  }\n}\n```
